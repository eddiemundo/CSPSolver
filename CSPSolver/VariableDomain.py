"""
Created on Feb 4, 2012

@author: Shenra

		dmc
       /   \
	lbc	    ubc
	   \   /
		asn

(Simplified) Propagation conditions
4: {asn, lbc, ubc, dmc}
3: {asn, lbc, ubc}
2: {asn, ubc}
1: {asn, lbc}
0: {asn}

(Simplified) Modification events
4: {asn, lbc, ubc, dmc} schedule(0, 4)
3: {lbc, ubc, dmc} (bbc) schedule(1, 4)
2: {lbc, dmc} (lbc) schedule(1, 1); schedule(3, 4)
1: {ubc, dmc} (ubc) schedule(2, 4)
0: {dmc} (inner) schedule(4, 4)

notify(mod event)
	if asn then schedule(



fixpoint()
1 while not q.empty()
2 p = q.head()
3 q.idle(p)
4 p.propagate()
5 P = propagators depending on events generated by p
6 for every p' in P : q.enqueue(p')

Gecode uses an indexed dependency array to store the propagator dependencies in
the Variable. In theory you could use a simple array for every propagation
condition instead, but they don't.

The reasoning is that they can iterate over multiple propagation conditions
without overhead if they store all the propagators in one array. This is C++
code btw, so this may not be useful in pure python coding.

"""
class EmptyVariableDomain:
	"""For fast copying"""
	__slots__ = ('lb', 'ub', 'assigned', '_propagatorQueue', '_idx', '_deps', '_solver')

class Variable():
	"""
	Variable is the domain that an integer variable can take. There are
	no holes allowed in this type of domain. Because there are no holes the
	domain can be represented as a lower and upper bound.
	
	A Variable can be failed, meaning it can contain no values.
	
	A Variable can be assigned, meaning it can contain only one value.
	
	A Variable schedules propagators to be run based on how the
	Variable has been changed. To do this it has callbacks that occur
	when either the lower or upper bound is changed.
	"""
	__slots__ = ('lb', 'ub', 'assigned', '_propagatorQueue','_idx', '_deps', '_solver')
	def __init__(self, lb, ub, pq=None):
		self.lb = lb
		self.ub = ub
		self.assigned = lb == ub
		#self.failed = lb > ub
		self._propagatorQueue = pq
		# indexed dependency array
		self._idx = [0, 0, 0, 0, 0, 0]
		self._deps = []
		# so we can fail a node faster. not sure if best architecture
		self._solver = None
	
	def __repr__(self):
		return str(tuple((self.lb, self.ub)))
	
	def __str__(self):
		return self.__repr__()
	
	def setlb(self, lb):
		if lb > self.lb:
			self.lb = lb
			if lb == self.ub:
				self.assigned = True
				self.notify(4)
			elif lb < self.ub:
				self.notify(2)
			else:
				self._solver._nodeFailed = True
				
	def setub(self, ub):
		if ub < self.ub:
			self.ub = ub
			if ub == self.lb:
				self.assigned = True
				self.notify(4)
			elif ub > self.lb:
				self.notify(1)
			else:
				self._solver._nodeFailed = True
	
	def copy(self):
		"""Returns a copy of this Variable"""
		copy = EmptyVariableDomain()
		copy.__class__ = self.__class__
		# copy instance variables
		copy.lb = self.lb
		copy.ub = self.ub
		copy.assigned = self.assigned
		copy._solver = self._solver
		#copy.failed = self.failed
		# here we assume dependencies don't change.
		# this is WRONG for the general case if people want to write super
		# clever propagators
		copy._idx = self._idx #self._idx[:]
		copy._deps = self._deps #self._deps[:]
		
		return copy
	
	def subscribe(self, p, condition):
		"""Subscribe a propagator to this variable for condition"""
		# note it is possible to subscribe the same propgator to a condition
		# twice
		# potential speedup: if subscribing to same condition, place item in
		# the last possible position for that condition
		idx = self._idx
		deps = self._deps
		# there are a maximum of 5 propgation conditions, and an end idx
		for i in reversed(range(condition + 1, 6)):
			idx[i] += 1
		deps.insert(idx[condition], p)
	
	def cancel(self, p, condition):
		"""Cancels propagator suscribed to condition"""
		idx = self._idx
		deps = self._deps
		# will raise a ValueError if there is no such propagator
		i = idx[condition] + deps[idx[condition]:idx[condition+1]+1].index(p)
		deps.pop(i)
		for i in reversed(range(condition + 1, 6)):
			idx[i] -= 1
			
	def notify(self, modificationEvent):
		"""Convenience method, but slower"""
		if modificationEvent == 4:
			self.schedule(0, 4)
		elif modificationEvent == 3:
			self.schedule(1, 4)
		elif modificationEvent == 2:
			self.schedule(1, 1)
			self.schedule(3, 4)
		elif modificationEvent == 1:
			self.schedule(2, 4)
		elif modificationEvent == 0:
			self.schedule(4, 4)
			
	def schedule(self, conditionStart, conditionEnd):
		"""Schedules propagators that depent on conditionStart to conditionEnd"""
		idx = self._idx
		for i in range(idx[conditionStart], idx[conditionEnd+1]):
			self._propagatorQueue.append(self._deps[i])
