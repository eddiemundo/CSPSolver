"""
Created on Feb 4, 2012

@author: Shenra

		dmc
       /   \
	lbc	    ubc
	   \   /
		asn

(Simplified) Propagation conditions
4: {asn, lbc, ubc, dmc}
3: {asn, lbc, ubc}
2: {asn, ubc}
1: {asn, lbc}
0: {asn}

(Simplified) Modification events
4: {asn, lbc, ubc, dmc}
3: {lbc, ubc, dmc}
2: {lbc, dmc}
1: {ubc, dmc}
0: {dmc}


fixpoint()
1 while not q.empty()
2 p = q.head()
3 q.idle(p)
4 p.propagate()
5 P = propagators depending on events generated by p
6 for every p' in P : q.enqueue(p')

Gecode uses an indexed dependency array to store the propagator dependencies in
the Variable. In theory you could use a simple array for every propagation
condition instead, but they don't.

The reasoning is that they can iterate over multiple propagation conditions
without overhead if they store all the propagators in one array. This is C++
code btw, so this may not be useful in pure python coding.

"""


	


class EmptyVariableDomain:
	__slots__ = ('lb', 'ub', 'assigned', 'failed')

class VariableDomain:
	"""Implements a event system similar to the Observer Pattern"""
	__slots__ = ('lb', 'ub', 'assigned', 'failed', 'space', 'idx', 'deps')
	def __init__(self, lb, ub):
		self.lb = lb
		self.ub = ub
		self.assigned = lb == ub
		self.failed = lb > ub
		self.space = None
		self._idx = [0, 0, 0, 0, 0, 0]
		self._deps = []
	
	def copy(self):
		"""Returns a copy of this VariableDomain"""
		copy = EmptyVariableDomain()
		copy.__class__ = self.__class__
		# copy instance variables
		copy.lb = self.lb
		copy.ub = self.ub
		copy.assigned = self.assigned
		copy.failed = self.failed
		copy.space = self.space
		
		return copy
	
	def subscribe(self, p, condition):
		"""Subscribe a propagator to this variable for condition"""
		idx = self._idx
		deps = self._deps
		# there are a maximum of 5 propgation conditions, and an end idx
		for i in reversed(range(condition + 1, 6)):
			idx[i] += 1
		deps.insert(idx[condition], p)
	
	def cancel(self, p, condition):
		"""Cancels propagator suscribed to condition"""
		idx = self._idx
		deps = self._deps
		# will return an error if there is no such propagator
		i = idx[condition] + deps[idx[condition]:idx[condition+1]+1].index(p)
		deps.pop(i)
		for i in reversed(range(condition + 1, 6)):
			idx[i] -= 1
	
	def schedule(self, conditionStart, conditionEnd):
		"""Schedules propagators that depent on conditionStart to conditionEnd"""
		idx = self._idx
		for i in range(idx[conditionStart], idx[conditionEnd+1] - 1):
			# add propagator to the queue
			pass
